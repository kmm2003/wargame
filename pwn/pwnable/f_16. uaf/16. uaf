힌트를 보니 use after free라는 버그에 대해 언급되어있다.

접속을 해보니 uaf.cpp라는 소스가 있다. 소스분석을 해보자.
1. 1,2,3중 입력값을 받는다.
2. 1을 입력할 경우 m,w class의 introduce()가 실행되어 자기소개 문구가 나온다.
3. 2을 입력할 경우 argv[1]만큼의 data배열이 할당되고 argv[2] 파일의 값을 읽어 data에 저장한다.
4. 3을 입력할 경우 인스턴스 m,w가 해제된다.

우선 어디가 취약점일지 감이 잡히지 않아서 
use after free 라는 버그에 대해 찾아보았다.
-------------------------------------------------------------------------------------------

간단하게 요약하면 heap영역에서 발생하는 취약점으로
예를 들어 10바이트 만큼을 동적할당 했다고 했을때 특정 값을 넣고
free()로 해제한 후

다시 똑같은 바이트만큼의 새로운 동적할당을 하면 똑같은 heap주소로 세팅이 되면서
그전에 넣었던 값을 확인 하거나 변경 할 수 있는 취약점이다.

이러한 현상이 발생하는 이유는 heap은 메모리를 효율적으로 사용하기 위해 해제했던 heap영역의 크기를 기억해놓고 똑같은 크기의 할당이 들어오면 똑같은 주소로 그대로 할당을 해서 재사용하기 때문이다.

즉, 효율적인 메모리 사용 때문에 이런 현상이 발생하는 것인데 이것이 취약점이 될 수 있다.

-------------------------------------------------------------------------------------------

문제로 돌아가서 소스를 다시 보자.

처음에 m, w 인스턴스가 동적으로 할당 되어있는 것이 확인되며

switch문 case 2를 보면 우리가 data영역에 동적으로 값을 입력할 수 있는 것이 확인된다.

이 두 가지를 통해 간단한 공격시나리오 작성이 가능 할 것 같다.

1. m 인스턴스가 얼마만큼의 크기로 할당됐는지 확인
2. case 3를 통해 인스턴스 해제
3. case 2를 통해 1에서 확인한 크기만큼 data를 동적으로 할당
4. data 영역에 introduce() 함수를 실행하는 대신 give_shell()을 실행하도록 함수 실행 주소를 변경
5. case 1을 통해 introduce() 실행
6. introduce() 대신에 내가 바꾼 give_shell() 실행되면서 클리어!

위 공격시나리오대로 진행해보도록 하자

우선 첫번째로 m인스턴스가 얼마만큼의 크기로 할당되었는지 확인해야 하는데 소스를 보면
Man클래스의 경우 Human클래스를 상속하고 있으며 Human클래스의 경우 age 4바이트 선언하고 있으며 name의 경우 'Jack'이라는 값이 들어갔음으로 4+4 총 8바이트를 할당 받고 있을 것으로 예상할 수 있다.

이후 예상 바이트 값을 토대로 gdb로 2를 입력값으로 사용한 이후에 break를 걸고 run 8 aaaaaaaa 로 디버깅을 시작하여 a값이 들어간 메모리 주소를 찾아보자


















*참고자료
Use After Bug => 정의: https://nroses-taek.tistory.com/156
                 공격시나리오: https://shotgh.tistory.com/62
                바이트: https://morae23.tistory.com/92
