힌트를 보니 operator priority 라는 힌트가 주어져있다.

먼저 인터넷에 검색해보니 연산자 우선순위라는 의미인 것 같다.

문제에 접속해서 mistake.c라는 소스를 보았다.
1. /home/mistake/password 경로의 파일이 정상적으로 오픈 되지 않을 경우 -1이 반환되어
if문 필터링에 걸려 에러가 발생한다.

2. pw_buf[11] 이라는 배열을 선언하며 
1에서 열었던 password 파일을 11 만큼 읽어서 pw_buf에 저장한다.
정상적으로 읽지 못하면 필터링에 걸려 에러가 발생한다.

3. pw_buf2[11] 배열을 선언하고
사용자의 입력을 받아 10자리만큼 pw_buf2에 저장한다.

4. pw_buf, 10을 인자로 넣은 xor 함수를 실행한다.

4-1. pw_buf2의 각자리를 1로 xor연산한다.

5. pw_buf, pw_buf2의 10자리가 같으면 문제가 해결된다.

결론적으로 password에서 읽어온 10자리와 내가 입력한 10자리의 각자리를 1로 xor연산한 값이 같으면 문제가 해결된다.

힌트를 보면 연산자 우선순위가 힌트인데
소스를 자세히 보니 1번 부분에서 파일을 open할때 보면
fd=open("/home/mistake/password",O_RDONLY,0400) < 0
위와 같이 소스가 써 있는데
연산자 우선순위에 의하면 < 이 = 보다 먼저이기 때문에
fd=(open("/home/mistake/password",O_RDONLY,0400) < 0)
위 처럼 될 것이고
fd=0 과 같이 될 것이다.

read()에서 fd=0이면 표준입력으로 입력을 받게 되고
따라서 우리가 입력값을 넣고 조작하여
최종 결과를 조작해 flag값을 얻어낼 수 있을 것이다.

실제로 mistake 파일을 실행해 보니 입력을 두번 받는 것을 확인 할 수 있었고
이 부분을 이용해 위에서 말한 취약점을 통해 flag값을 얻어내면 될 것 같다.

최종 공격시나리오
1. pw_buf에 0000000000을 넣는다.
2. 1111111111을 넣어서 xor 했을 때 0000000000이 되게 만든다.

공격 시나리오 대로 해보자!
(주의: sleep 때문에 첫번째 값이 입력받고 딜레이가 있다.)

클리어!!
 


