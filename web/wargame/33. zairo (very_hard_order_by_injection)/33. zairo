힌트를 보니 sql injection 문제라고하며
with adm1nkyj 라고 써있는 것으로 봐서는 전에 풀었던 adm1nkyj 문제와 비슷한 유형일 것으로 예상된다.

문제에 접속하니 adm1nkyj 문제처럼 바로 소스가 나온다.

소스를 읽어보자.

소스를 읽어보니 adm1nkyj 문제와 대부분의 부분들은 전부 다 똑같고
$pw === $tmp_pw && $flags === $tmp_flag 조건을 맞춰야되는게 목적인 것도 
똑같다.

그러나 다른 점은 이번에는 메타데이터를 사용못하게 하는 것과 함께 where,=,( 를 못 쓰게 하였다.

저번 문제에서 풀었던 대로라면 
1. 속성 갯수와 순서 구하기
2. id값 구하기
3. pw값 구하기
4. flag값 구하기

위와 같은 순서로 문제풀이가 되야한다.

1번부터 해보자
SELECT * FROM findflag_2 WHERE $id_column='' union select 1,2,3,4,5 %23' and $pw_column='{$pw}'
위와 같은 쿼리로 무난하게 구할 수 있을 것 같다.

구해보니 저번 문제와 똑같이 속성 5개에 id속성은 두 번째 속성으로 나왔다.

이제 2번을 해보자
SELECT * FROM findflag_2 WHERE $id_column='' or 1 order by 5 %23' and $pw_column='{$pw}'
$id값도 저번 문제처럼 위와 같은 쿼리로 무난하게 구할 수 있을 것이다.

구해보니 $id값은 zairowkdlfhdkel라는 값이 나왔다.

3번 차례인데 pw값을 구해야 한다.
저번 문제의 경우 pw값을 구하기 전에 pw_column을 먼저 구했었다.
SELECT * FROM findflag_2 WHERE $id_column='' union select 1,' and $pw_column=',3,4,5 %23'
이번에도 저번 문제와 똑같은 방법 union injection으로 구하면 풀릴 것이다.

풀어보니 $pw_column이 xvvcPw4coaa1sslfe이라는 값이 나왔다.

이제 pw값을 구해보자
SELECT * FROM findflag_2 WHERE $id_column='' union select 1,xvvcPw4coaa1sslfe,3,4,5 from findflag_2 %23'
이번에도 역시 저번 문제와 똑같이 풀면 해결 될 것이다. (이쯤되니 문제를 너무 똑같이 낸거 아닌가 하는 생각이 든다;;;)

$pw값이 wkdlfhpw!!@%%#@@#이 나왔다.

이제 마지막으로 대망의 4번 flag값을 구해보자!
저번 문제에서도 flag값을 구하는 것이 가장 힘들었었는데
역시 이번문제에서도 flag값을 구하는 것이 가장 힘들것 같다.
우선 flag값을 구하는데 있어서 저번과 같은 방법을 사용 할 수는 없다.

*저번문제에서 flag 구할때 사용했던 쿼리
SELECT * FROM findflag_2 WHERE $id_column='' union select 1,flag,3,4,5 from(select 1,2,3,4 flag,5 union select * from findflag_2 limit 1,1)x'

왜냐하면 위 쿼리가 저번 문제의 풀이 쿼리인데 여기서는 ( 가 사용이 됐기 때문이다.

그렇다면 완전 다른 방법의 풀이를 생각해봐야하는데......
괄호를 쓸수가 없으니 우선 저번 풀이처럼 테이블의 정보를 일부만 select해서 flag값을 한번에 가져오는 이런방식으로는 문제풀이가 안 될 것 같다.

즉, flag값을 가져와 한번에 UI에 출력하는 방법은 보이지 않는다.

따라서 UI에 한번에 출력하는 방법말고 브루트포싱하여 한글자씩 가져오는 방법을 생각해보았다.
 
SELECT * FROM findflag_2 WHERE $id_column='zairowkdlfhdkel' union select 1,2,3,'a',5 order by 4 desc %23

위와 같이 예제 코드가 있는데
위 쿼리를 이용하면 findflag_2의 네번째 속성인 flag의 첫번째 자리 값이 'a' 보다 큰 값인지 작은 값인지 확인 할 수 있다.

'a'보다 크거나 같은 값이면 zairowkdlfhdkel가 출력될 것이고 작은값이면 2가 출력될 것이다!!
(클때와 같을때가 같은 값이 출력되는 이유는 union을 기준으로 앞이 zairowkdlfhdkel 계정 레코드이고 따라서 같으면 상단에 있는 레코드의 id인 zairowkdlfhdkel이 출력되기 때문이다.)

이런 방법으로 하나씩 비교해가며 모든 자리수를 구하면 될 것 같다!

다만 여기서 문제점이 count를 통해 브루트포싱을 막고있으면 최대 150번 까지만 입력을 허용하고 그 다음에는 flag값을 초기화한다는 것이다.

따라서 단순히 계속 비교하는 것은 무리가 있을 것 같다.

그래서 알고리즘적으로 접근을 해보았는데
우선 비교할 문자열을 아스키코드로 나열해보면 33~90 까지이고 이것을 이진탐색 알고리즘으로 해당하는 값을 찾아보는 것은 어떨까 생각해보았다.

소모될 count를 계산해보았는데
58 29 15 8 4 2 1
위는 count한번을 소모할때마다 남는 경우의 수이고 따라서 이진탐색 알고리즘을 통해 최대 7번이면 1자리의 값을 구할 수 있다!!

알고리즘을 쉽게 설명하면
flag[i] 값이 pivot 보다 더 크거나 같으면 id 출력
flag[i] 값이 pivot 보다 더 낮으면 2 출력
최종적으로 start가 end보다 커지면 그게 flag값이다!

코드를 돌려보면서 값을 확인해보니
카운트를 150보다 훨씬 많이 소모하면서 150이내에 값이 전부 구해지지 않는 것 같다...ㅠㅠ

근데 돌리다 보니까 알아낸 사실인데 나오는 값이 전부 알파벳 또는 숫자인 것으로 확인된다.
그렇다면 아스키코드로 비교하지 말고 숫자,알파벳으로 이루어진 문자열을 하나 만들어서 그 안에서 구하면
알고리즘에 사용되는 카운트 횟수가 훨씬 줄어들 것이다.

코드를 다시 만들어서 돌려보았다. (fail_flag.py)

돌려보다보니 최대 26자리? 정도까지가 한계이고 더 이상의 자릿수를 구할 수가 없다...ㅠㅠ
아마 30자리가 flag의 길이이지 않을까하고 이진탐색 알고리즘보다 빠른 알고리즘을 찾아보기도 하고 응용해가면서
변화를 줘보기도 수차례해보았으나 삽질이였다...ㅠㅠ

아무리 봐도 이진탐색보다 빠르게 찾을수 있는 방법이 없다고 생각하면서 계속 돌려보던중 엄청난 사실을 깨달았다!!

flag값으로 출력된 값의 모든 자릿수를 서로 비교해보니 모두 다 중복되는 값이 없게 출력된다는 것이다!!!

여러번 다시 시도해봐도 똑같은 결과가 나온다!!

그렇다면 중복되는 값이 없기때문에 한 자리를 구할때마다 배열에서 그 값은 제외하고 알고리즘을 돌린다면??

훨씬 많은 자릿수를 구할 수 있을 것이다!!(기하급수적으로 구할 수 있는 자릿수가 증가할 것이다.)

즉, 처음 배열 36자리(숫자+문자) 중 첫자리를 구하면 그다음에는 배열 35자리중에서 값을 찾고
그다음은 34...33....32.......1 이런식으로 값을 찾는다는 의미이다.

이렇게 30자리를 알아내는데 성공했으면 값을 확인해보니 flag값의 길이가 더 길다는 사실을 알았고
여기서 나는 눈치채게 되었는데 숫자+문자가 총 36자리니까 flag값도 서로다른 숫자+문자 총36자리로 되어있겠구나~! 라고 생각해보았다.

위 생각대로 36자리를 구해보았다. (flag.py)

깔끔하게 36자리의 flag값이 나왔고 이 값을 위에서 구한 id,pw와 함께 전송해보니....

드디어 클리어!!!!!!!

고생한 만큼 너무 짜릿한 문제였다!! ㅎㅎ

