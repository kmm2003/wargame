힌트를 보니 just for fun [season3]의 일부분이라는 힌트가 주어져있다.
아직 뭔소린지 모르겠으니 문제로 넘어가보자

문제에 접속하니 alert창을 통해 swp가 힌트라고 주어져있다. 
swp의 경우 확장자로 vi편집기로 편집중 의도치않게 중지되면 자동으로 swp 임시파일이 백업된다.

swp파일이 숨어있다는 것 같은데 어떤 swp파일을 봐야될 지 우선 코드 오더링을 쭉 해보았지만
대부분 css 관련된 코드일 뿐 딱히 눈에 띄는 부분이 보이지 않았다.

코드 오더링을 할때 측면 header부분의 a태그에서 계속 index.php로 이동하는 것을 보고 설마?
하는 마음으로 .index.php.swp 로 url을 통해 접속해보니 index.php.swp파일이 다운로드된다!!
유레카!!(참고로 index.php.swp 앞에 .이 붙는 이유는 swp파일 같은 경우에는 기본적으로 숨김파일로 생성되기 때문이다.)

다운로드 받은 파일을 보니
swp파일이라서 그런지 깨진형태로 보기가 좀 까다롭게 구성되어있다.
코드의 순서도 뒤죽박죽인듯 하다;;;

대충 코드를 핵심만 뽑아 짜맞춰서 보면
"select * from member where no=".$_GET['no']);
위 쿼리를 실행하고 그 결과값을 $result 변수에 저장하는 것과
custom_firewall($_GET['no'])의 리턴값을 $test에 저장 후 그 값이 0인지 아닌지에따라
필터링을 하는 것 같다. (필터링에 걸리면 no hack이라는 문구를 출력)

우선 둘 중 위 쿼리부터 보면 우리가 보낸 no파라미터 값을 이용해 sql 쿼리를 실행하는데
아까 코드오더링을 해보았을때 no파라미터를 보내는 것은 header부분의 CD80, Orang, Comma등을 눌렀을 때 밖에 없고 이 부분을 누를 경우에 위 쿼리가 발생하며 맨 앞이 #이 아니면 페이지 이동이 정상적으로 되지않는다.
그렇다고 맨앞에 #을 넣으면 값자체가 정상값이 아니여서 이동이 제대로 되지 않는 것 같다.

우선 no파라미터값을 보내 위 쿼리문에 injection을 시도해보고 싶기 때문에 잠기 js의 필터링을 우회하기 위해 브라우저의 js기능을 끄고 파라미터값을 보내보았다.

header부분중 CD80을 눌러보니 가운데에 CD80이라고 값이 뜨는 것을 확인 할 수 있었다.
나머지도 눌러보니 각각의 값이 뜨는 것을 확인했다.

혹시나 하는 마음에 이 3가지 외에 (즉, 1,2,3 외에) 다른 값들도 넣어보았는데
no=0을 보낼시 admin값이 나오는 페이지가 뜨는 것을 확인 할 수 있다.

여기서 우선 admin의 계정으로 로그인하는 문제라는 것을 생각해 볼 수 있었고 
이번에는 no파라미터를 이용해 위 쿼리에 injection을 시도해보았다.

select * from member where no=4 or no=1
위와 같은 쿼리를 만들기 위해 4 or no=1을 전송해보니 
no hack이라는 문구가 뜬다.

아까 다운로드 받은 php에 있던 no hack이라는 문구가 뜨는 것을 확인 할 수 있다.
아마 custom_firewall함수를 통해 사용자의 파라미터 입력값을 검증하고 필터링하는 것 같다.

어떤 값이 필터링 되는지 확인해보았는데
or가 필터링 되는 것을 확인 할 수 있었다.

혹시 똑같은 의미인 ||로는 우회가 될까싶어
4 || no=1를 전송해보니
Comma라는 문구가 가운데에 뜨면서 injection에 성공했다!!

이제 다른 필터링도 이런식으로 우회하면서 admin의 계정 정보를 구하면 되겠다.
어떤 문구가 필터링에 걸리는지 한번 조사해보았는데
or,and,select,from,if,union,0x,ord,ascii,substr,substring,left,right,mid등등
위와 같은 문자들이 모두 필터링 되는 것을 확인 할 수 있었다.

select * from member where no=4 || length(id)=5
위와 같은 쿼리를 만들기 위해 값을 전송해보니
원하던대로 admin이라는 문구가 떴다!!

위의 방식대로 pw값도 유추하면 될 것 같다. 
길이부터 구해보니
select * from member where no=4 || length(pw)={i}
32자리가 나오는 것을 확인 할 수 있었다.

이번에는 pw값을 구해보려했지만 substr,substring,left,right,mid 문자열을 추출하는 함수들을
사용하지 못해 고민하던중 구글링을 해보았고
결과 lpad라는 함수를 발견했다.
이 함수를 이용해 pw값을 구해보니(lpad.py)

# 인젝션 우회 출처
http://www.dreamy.pe.kr/zbxe/CodeClip/3769526

해쉬암호같은 pw가 나왔다. 아마 해쉬하여 pw를 보관하는 듯 하다.

혹시나 싶어 이 pw를 구글에 검색해보니
맨 앞이 0e로 시작하는 magic hash 취약점을 가진 pw로
무슨 알고리즘으로 암호화 됐는지만 알면 magic hash 취약점을 이용해 magic string을 이용하여
로그인을 할 수 있을 것이다.

# magic string 출처
https://humit.tistory.com/170

또한 구글에 검색했을때 md5, haval 등의 해시함수가 나오는 것을 보고 이 해쉬함수들중 32자리가 출력되는 해쉬의 magic string값을 모두 한번씩 넣어보니
haval128,5 해시함수의 magic string값으로 로그인이 되었다!!
pw가 haval128,5로 만들어졌나보다.

flag값이 나왔다. 클리어!!


