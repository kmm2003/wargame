참고자료 -> ** https://whitesnake1004.tistory.com/601 ** 
==> 사이트 아래쪽 내용이 이해가 안되던거를 해결해줌 꼭 나중에도 다시 보고 여기에 정리할 것!

1을 누르면 Apple, 2를 누르면 Banana

3을 누르면 Secret이라는 글씨와 함께 테이블의 속성이 id,no 두개가 있음을 알려주고
no==3의 id를 구하라는 것이 목적이다.

Password 폼에 아무 값이나 넣어보니 pw 파라미터와 함께 get방식으로 전달되는 것을 확인할 수 있다.

혹시나 싶어 Password 폼에 Secret을 넣어봤지만 역시나 안된다 ㅋㅋ

1,2,3을 각각 눌렀을 때도 no 파라미터와 함께 get방식으로 전달된다

여태까지 나온 힌트들을 토대로 sql 쿼리문을 유추해 보면 다음과 같다
==> select id from [table_name] where no=${no}
==> 근데 생각해보니 이런식이면 Secret이 정답이어야 되는게 맞으니까 위에 쿼리는 아닐듯?? 그래도 대충 이런식임을 유추해 볼 수 있다.

여기서 생각해 볼 수 있는 것은 1이나 2의 값을 no에 넣었을때 출력되는 값을 알고있음으로 이를 토대로
blind sql injection을 시도해볼수 있을 것 같다.

blind sql injection을 시도하기 위해 아래와 같은 식을 작성하였다.
if(length(id)like({i}),3,99)

-------------------------------------------------------------------------------------------
여기서 중요하게 알아야 하는 사실이 있는데
no  id
1   apple
2   banana
3   alsrkswhaql
의 테이블이 존재한다고 할때
select * from table where no=if(substr(id,2,1)like(0x6c),3,1)
이라는 쿼리를 사용한다고 치자(아래와 연결)
-------------------------------------------------------------------------------------------
첫번째 글자에서 no=3만 출력되는 이유는 아래와 같습니다.

 

id의 첫번째 글자가 a인지 비교를 하는데 no=1 부터 no=3 까지 총 3번을 비교합니다.

no=1의 레코드를 보면 id=apple 이기 때문에 3이라는 값을 반환을 합니다.

하지만 no=1과 no=3 즉, 1 != 3 이기 때문에 no=1의 레코드 값이 반환 되지 않습니다.

 

no=2의 레코드를 보면 id=banana 이기 때문에 1이라는 값을 반환하는데 이것도 위의 예시처럼 no=1을 반환하지만 no=2 와 같지 않기 때문에 반환을 하지 않는 것이였습니다.

 

마지막으로 no=3의 레코드를 보면 id=alsrkswhaql 였고 3이라는 값을 반환하기 때문에 no=3과 반환값인 no=3과 같은지 보고 같기 때문에 no=3의 레코드만 출력이 되는 것이였습니다.

 

id의 두번째 글자도 l이랑 비교를 해보면 아래와 같습니다.

no=1의 레코드의 apple 과 비교했을때 false 이기 때문에 1을 반환하는데 no의 값이 같기 때문에 no=1 레코드 출력!

no=2의 레코드의 banana 와 비교했을때 false 이기 때문에 1을 반환하지만 no의 값이 다르기 때문에 스킵!

no=3의 레코드의 alsrkswhaql 와 비교했을 때 true 이기 때문에 3을 반환해서 no의 값과 같기에 no=3 레코드를 출력하게 됩니다.

 

그렇기 때문에 2개의 레코드가 반환이 되어서 ?no=1 도 아니고 ?no=3도 아닌 페이지가 출력이 되는 것입니다.

 

3줄요약을 해보면 아래와 같습니다.

1. 조건절은 DB 레코드 하나마다 처리가된다.

2. 조건절은 1개 이상의 조건문으로 이루어져있다.

3. column 에 if문을 붙혀 사용할 때, if 안의 조건문이 참인지 거짓인지에 대해 해당 레코드와 column 값이 일치할 때 해당 column 내용을 반환한다.

이게 이해가 안되면 최상단의 url에서 확인 ㄱㄱ
-------------------------------------------------------------------------------------------

여기서 핵심이라고 할 수 있는 원리가 3줄요약의 3번인데 3번 때문에 헷갈리지 않기 위해서라면
if(length(id)like({i}),3,99)
위 쿼리처럼 false 경우의 반환값에는 레코드가 존재하지 않는 값을 넣어주어야 좋다.

우선 테스트를 위하여 if(length(id)like(5),1,99) 과 if(length(id)like(4),1,99)
를 각각 no의 값으로 한번씩 넣어보겠다.
결과는 예상대로 첫번째 쿼리는 apple을 두번째 쿼리는 빈결과를 반환하는 것을 알 수 있다.
따라서 이러한 방법을 바탕으로 no==3의 id값의 길이를 알아내어 보겠다.

(webhacking_9-1.py)
위 파이썬 코드로 값을 구해본 결과 no3의 id값 길이는 11자리이다.

if((ascii(substr(id,{i},1)))like({j}),3,99)

위 쿼리를 이용하여 11자리의 id값 즉, 패스워드 값을 구해보겠다.

값이 구해지지 않는다....왜 안구해지나 했더니 ascii가 필터링된다.....
근데 더 충격적인것은 ord,hex 모두다 필터링된다...ㅁㅊ ㅠㅠ

문제를 고민하며 조사하다가 안 사실인데 substr() 함수로 나오는 리턴값이 문자인데 like함수를 써서 값을 비교할때 문자뿐만 아니라 16진수로 비교해도 비교가 가능하다는 사실이다;;;;;;

like()함수 인자를 16진수로 바꾸어서 파이썬 코드로 쿼리를 전송해보았다.

........%%%%%%%%%%....라는 답이 나온다....허허;;;;;

%의 아스키 코드가 37(10진수)이기 때문에 for문 j의 값을 38~133으로 바꿔서 코드를 실행해봤다.

이번에는 ALSRKSWHAQL이라는 값이 나왔다!! 드디어 풀리는 것 같다. 패스워드값으로 폼에 입력해보자!

..........안풀린다..........

여기서 또 한참 고민하다가 엄청난 사실을 알았다..........substr()로 나온 문자가 대문자든 소문자든 구분하지않고 like(16진수)의 값은 같은 알파벳이면 참 쿼리로 인정된다는 것이다.....

즉 , substr() == 'a' 가 나왔을떄 like()함수의 인자로 'a'의 16진수값이 들어가야 참인 것이 당연한데 'A'의 16진수값이 들어가도 참으로 인정된다는 것이다....... 허허 시발;;;

for문 j의 값을 소문자 영역의 10진수로만 바꿔서 코드를 실행하니 똑같은 값으로 alsrkswhaql라는 소문자 값이 나왔다.... password로 전송해보자...

클리어!!! 힘든 문제였다...ㅠ (webhacking_9-1.py)


